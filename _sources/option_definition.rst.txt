========================
广义期权的一般创建方式
========================

当前市场上有很多常见的障碍期权，比如 up out down in 、气囊结构、保本雪球等等，但是市面上绝大多数复杂的障碍期权都能够通过简单的障碍期权组合而成。为了方便定义这些复杂的障碍期权，将单障碍期权分为两种：单障碍敲入期权及单障碍敲出期权，将双障碍期权分为两种，双障碍敲出期权及敲入敲出型期权，并在下文中对这些期权的创建方式进行详细说明。



单障碍敲入期权
====================
敲入型期权是指期权触及敲入障碍后激活另一种期权，激活后的期权持有至到期。

.. list-table:: 

    * - **定义要素**
      - **说明**
    * - 敲入方向
      - 向上敲入 **UP_IN** 或向下敲入 **DOWN_IN**
    * - 敲入观察日
      - 任意定义，一般根据观察频率、初始日期、期限等生成
    * - 敲入障碍价格
      - 对应的每个敲入观察日有对应的敲入障碍价格
    * - 敲入赔付
      - 单障碍期权敲入后激活的期权，指定 :doc:`qlib_doc/payoff` 类型
    * - 未敲入赔付
      - 指定 :doc:`qlib_doc/payoff` 类型
    * - 日历
      - 指定 :doc:`qlib_doc/calendar`
  


接口示例
----------------

.. list-table:: 

    * - **向下敲入看跌期权条款**
      -    
    * - 开始日期
      - 2021年3月1日
    * - 结束日期
      - 2021年9月1日
    * - 敲入方向
      - 向下敲入 **DOWN_IN**
    * - 敲入观察频率
      - 按月观察
    * - 敲入障碍价格
      - 80.0
    * - 敲入赔付
      - PUT，参与率为100%，执行价为100
    * - 未敲入赔付
      - 一笔价值为5的现金
    * - 日历
      - A股交易日历

该期权在单障碍敲入期权接口中的实现如下： 

.. code-block:: c++

    #include "qlib/barrier_option.h"
    #include "qlib/schedule.h"
    #define A_STOCK "[path]/Calendars/China.txt"

    int main()
    {
    	auto cal = Calendar(A_STOCK);
        auto start_date = Date(2021, 3, 1);
        auto end_date = Date(2021, 9, 1);
        auto observation_dates = Schedule(start_date, end_date, Period(1, TimeUnit::MONTH), 
                                            BusinessDayConvention::FOLLOWING,
                                            DateGenerationRule::FORWARD, cal, true, false);
        
        std::vector<double> barriers(observation_dates.size(), 80.0);
        auto ki_payoff = Vanilla(100, OptionType::PUT);
        auto nki_payoff = Cash(5.0);
        auto ki_opt = KnockInBarrierOption(BarrierType::DOWN_IN, observation_dates, 
                                            barriers, ki_payoff, nki_payoff, cal);

        
    }



单障碍敲出期权
=======================
敲出型期权是指终止，触及敲出障碍则该期权到期，在实际金融市场中，敲出后一般有相应的赔付。

.. list-table:: 

    * - **定义要素**
      - **说明**
    * - 敲出方向
      - 向上敲出 **UP_OUT** 或向下敲出 **DOWN_OUT**
    * - 敲出观察日
      - 一般根据观察频率、初始日期、期限等生成
    * - 敲出障碍价格
      - 对应的每个敲出观察日有对应的敲出障碍价格
    * - 敲出赔付
      - 敲出终止后的赔付，指定 :doc:`qlib_doc/payoff` 类型
    * - 到期赔付
      - 即未敲出的到期赔付，指定 :doc:`qlib_doc/payoff` 类型
    * - 日历
      - 指定 :doc:`qlib_doc/calendar`
  

接口示例
----------------

.. list-table:: 

    * - **向上敲出看涨期权测试条款**
      -    
    * - 开始日期
      - 2021年3月1日
    * - 结束日期
      - 2021年9月1日
    * - 敲入方向
      - 向上敲出 **UP_OUT**
    * - 敲出观察频率
      - 按月观察
    * - 敲出障碍价格
      - 100.0
    * - 敲出赔付
      - 一笔价值为5的现金
    * - 到期赔付
      - CALL，参与率为100%，执行价为90
    * - 日历
      - A股交易日历

该期权在单障碍敲出期权接口中的实现如下： 

.. code-block:: c++

    #include "qlib/barrier_option.h"
    #include "qlib/schedule.h"
    #define A_STOCK "[path]/Calendars/China.txt"

    int main()
    {
    	  auto cal = Calendar(A_STOCK);
        auto start_date = Date(2021, 3, 1);
        auto end_date = Date(2021, 9, 1);
        auto observation_dates = Schedule(start_date, end_date, Period(1, TimeUnit::MONTH), 
                                            BusinessDayConvention::FOLLOWING,
                                            DateGenerationRule::FORWARD, cal, true, false);
        
        std::vector<double> barriers(observation_dates.size(), 100.0);
        
        std::vector<Payoff> ko_payoffs(observation_dates.size(), Cash(5.0));
        auto maturity_payoff = Vanilla(90, OptionType::CALL);
        auto ko_opt = KnockOutBarrierOption(BarrierType::UP_OUT, observation_dates, barriers,
                                             ko_payoffs, maturity_payoff, cal);
        
    }




双障碍敲出期权
====================
双障碍敲出期权是指有两个敲出障碍的期权，期权只要触及一方障碍则该期权到期，在实际金融市场中，敲出后一般有相应的赔付。


.. list-table:: 

    * - **定义要素**
      - **说明**
    * - 向上敲出观察日
      - 任意定义，一般根据观察频率、初始日期、期限等生成
    * - 向上敲出障碍价格
      - 对应的每个向上敲出观察日有对应的向上敲出障碍价格
    * - 向上敲出赔付
      - 向上敲出终止后的赔付，指定 :doc:`qlib_doc/payoff` 类型
    * - 向下敲出观察日
      - 任意定义，一般根据观察频率、初始日期、期限等生成
    * - 向下敲出障碍价格
      - 对应的每个向下敲出观察日有对应的向下敲出障碍价格
    * - 向下敲出赔付
      - 向下敲出终止后的赔付，指定 :doc:`qlib_doc/payoff` 类型
    * - 未敲出赔付
      - 指定 :doc:`qlib_doc/payoff` 类型
    * - 日历
      - 指定 :doc:`qlib_doc/calendar`



接口示例
----------------

.. list-table:: 

    * - **双障碍敲出期权测试条款**
      -    
    * - 开始日期
      - 2018年1月4日
    * - 结束日期
      - 2019年1月4日
    * - 向上敲出观察频率
      - 按月观察
    * - 向上敲出障碍价格
      - 120.0
    * - 向上敲出障碍赔付
      - 一笔价值为5的现金
    * - 向下敲出观察频率
      - 按日观察
    * - 向下敲出障碍价格
      - 80.0
    * - 向下敲出障碍赔付
      - 一笔价值为5的现金
    * - 未敲出赔付
      - CALL，参与率为100%，执行价为90
    * - 日历
      - A股交易日历


该期权在单障碍敲出期权接口中的实现如下： 

.. code-block:: c++

    #include "qlib/double_barrier_option.h"
    #include "qlib/schedule.h"
    #define A_STOCK "[path]/Calendars/China.txt"

    int main()
    {
        auto cal = Calendar(A_STOCK);
        auto start_date = Date(2018, 1, 4);
        auto end_date = Date(2019, 1, 4);
        
        // 设置向上敲出事件
        auto up_dates = Schedule(start_date, end_date, Period(1, TimeUnit::MONTH),
                                  BusinessDayConvention::FOLLOWING,
                                  DateGenerationRule::FORWARD, cal, true, false);
        std::vector<double> up_barriers(up_dates.size(), 120.0);
        std::vector<Payoff> up_payoffs(up_dates.size(), Cash(5));
        
        // 设置向下敲出事件
        auto down_dates = Schedule(start_date, end_date, Period(1, TimeUnit::DAY),
                                  BusinessDayConvention::FOLLOWING,
                                  DateGenerationRule::FORWARD, cal, true, false);
        std::vector<double> down_barriers(down_dates.size(), 80.0);
        std::vector<Payoff> down_payoffs(down_dates.size(), Cash(5));
        
        // 未敲出赔付
        auto unhit_payoff = Vanilla(90, OptionType::CALL);
        
        auto double_ko_opt = DoubleKnockOutBarrierOption(up_dates, up_barriers, up_payoffs, 
                                                         down_dates, down_barriers, down_payoffs,
                                                         unhit_payoff, cal);
    }


敲入敲出型期权
====================
敲入敲出型期权是指双障碍的一方为敲入型障碍，另一方为敲出型障碍，期权触及敲入障碍一方后激活另一种期权，激活后的期权持有至到期，期权触及敲出障碍一方后则该期权到期，在实际金融市场中，敲出后一般有相应的赔付， :ref:`雪球期权 <snowball def>` 为该类型的常见期权。

.. list-table:: 

    * - **定义要素**
      - **说明**
    * - 障碍类型
      - 向上敲出向下敲入 **UP_OUT_DOWN_IN** 或 向下敲出向上敲入 **UP_IN_DOWN_OUT**
    * - 敲出日期
      - 任意定义，一般根据观察频率、初始日期、期限等生成
    * - 敲出障碍价格
      - 对应的每个敲出观察日有对应的敲出障碍价格
    * - 敲出赔付
      - 敲出终止后的赔付，指定 :doc:`qlib_doc/payoff` 类型
    * - 敲入日期
      - 任意定义，一般根据观察频率、初始日期、期限等生成
    * - 敲入障碍价格
      - 对应的每个敲入观察日有对应的敲入障碍价格
    * - 敲入赔付
      - 敲入后激活的期权，指定 :doc:`qlib_doc/payoff` 类型
    * - 未敲出未敲入赔付
      - 指定 :doc:`qlib_doc/payoff` 类型
    * - 日历
      - 指定 :doc:`qlib_doc/calendar`



接口示例
----------------

.. list-table:: 

    * - **敲入敲出型期权测试条款**
      -
    * - 障碍类型
      - 向上敲出向下敲入 **UP_OUT_DOWN_IN**
    * - 开始日期
      - 2018年1月4日
    * - 结束日期
      - 2019年1月4日
    * - 敲出观察频率
      - 按月观察
    * - 敲出障碍价格
      - 100.0
    * - 敲出障碍赔付
      - 一笔价值为5的现金
    * - 敲入观察频率
      - 按日观察
    * - 向下敲出障碍价格
      - 80.0
    * - 敲入障碍赔付
      - -PUT，参与率为100%，执行价为100
    * - 未敲出赔付
      - CALL，参与率为100%，执行价为90
    * - 日历
      - A股交易日历


该期权在单障碍敲出期权接口中的实现如下： 

.. code-block:: c++

    #include "qlib/double_barrier_option.h"
    #include "qlib/schedule.h"
    #define A_STOCK "[path]/Calendars/China.txt"

    int main()
    {
        auto cal = Calendar(A_STOCK);
        auto start_date = Date(2018, 1, 4);
        auto end_date = Date(2019, 1, 4);
        
        // 敲出事件
        auto out_dates = Schedule(start_date, end_date, Period(1, TimeUnit::MONTH),
                                  BusinessDayConvention::FOLLOWING,
                                  DateGenerationRule::FORWARD, cal, true, false);
        std::vector<double> out_barriers(out_dates.size(), 100.0);
        std::vector<Payoff> out_payoffs(out_dates.size(), Cash(5));
        
        // 敲入事件
        auto in_dates = Schedule(start_date, end_date, Period(1, TimeUnit::DAY),
                                 BusinessDayConvention::FOLLOWING,
                                 DateGenerationRule::FORWARD, cal, true, false);
        std::vector<double> in_barriers(in_dates.size(), 80.0);
        auto in_payoff = -Vanilla(100, OptionType::PUT);
        
        // 未敲出赔付
        auto unhit_payoff = Vanilla(90, OptionType::CALL);
        
        auto in_out_opt = InOutBarrierOption(BarrierType::UP_OUT_DOWN_IN, out_dates, out_barriers, out_payoffs,
                                                in_dates, in_barriers, in_payoff, unhit_payoff, cal);
    }
